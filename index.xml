<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Blog of Auold</title>
        <link>https://auold.github.io/</link>
        <description>Recent content on Blog of Auold</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Thu, 02 Mar 2023 23:51:36 +0800</lastBuildDate><atom:link href="https://auold.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>AI绘图中的放大算法对比</title>
        <link>https://auold.github.io/post/amplification_algorithm_comparison/</link>
        <pubDate>Thu, 02 Mar 2023 23:51:36 +0800</pubDate>
        
        <guid>https://auold.github.io/post/amplification_algorithm_comparison/</guid>
        <description>&lt;h2 id=&#34;放大的必要性&#34;&gt;放大的必要性&lt;/h2&gt;
&lt;p&gt;在最近摸索 &lt;em&gt;Stable Diffusion&lt;/em&gt; 绘图的过程中，我发现了一个比较常见的现象。如果在最开始画图时直接就设置一个较大的宽度和高度(例如1920*1280)，很容易让AI不知所措，把很多东西都塞到一幅画里面，或者直接就是出来一幅意义不明的画。即使在提示词中使用了诸如 &lt;em&gt;&amp;ldquo;solo&amp;rdquo;&lt;/em&gt; 之类的描述也很难抑制这个现象的发生。&lt;/p&gt;
&lt;p&gt;所以我认为目前比较好且稳定的方式，是先画一幅宽和高均较小的画，再通过 &lt;em&gt;Hires. fix&lt;/em&gt; 功能对其进行放大。根据经验，&lt;strong&gt;当宽高比小于1024*1024时，尝试过的大多数模型都可以稳定出图&lt;/strong&gt;，没有大的结构性的问题。&lt;/p&gt;
&lt;h2 id=&#34;放大带来的问题&#34;&gt;放大带来的问题&lt;/h2&gt;
&lt;p&gt;但放大也不是那么容易用的，不良的算法和重绘系数选择很有可能会将一副原本不错的画完全毁掉。在之前尝试某个模型的时候，不管我怎么在反向提示词里面加关于手指异常的提示，最终得到的图就从来没有五根手指的，甚至还有其他的地方变手指的。然而当我观察图片的生成过程时，我才发现最初生成的图片手指确实是好的，手指的异常是在放大的过程中出现的！&lt;/p&gt;
&lt;p&gt;由此，才产生了这篇文章，我决定简单对比一下目前内置的这些放大算法效果的差异。我本人对这些不同算法的原理了解并不深刻，这里的对比更多是绘图效果的直接对比。事实上，后来我才慢慢发现&lt;strong&gt;不同放大算法的最优重绘幅度差别不小&lt;/strong&gt;，所以下面的实验并不能很好的展示各个放大算法最好的效果，仅仅算是对于这个功能初步的一些探索吧。&lt;/p&gt;
&lt;h2 id=&#34;实验条件&#34;&gt;实验条件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CPU: Intel i5-12400F&lt;/li&gt;
&lt;li&gt;内存: 32GB&lt;/li&gt;
&lt;li&gt;显卡：NVIDIA GeForce RTX 3060 Ti (8GB)&lt;/li&gt;
&lt;li&gt;模型：dalcefoPainting_2nd&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;如果某个测试中没有出现对应的放大算法，那就是爆显存没画出来，请谅解&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;测试一&#34;&gt;测试一&lt;/h2&gt;
&lt;p&gt;测试一的测试条件如下图所示。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://auold.github.io/amplification_algorithm_comparison/test1/test1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;test1&#34;
	
	
&gt;
&lt;strong&gt;测试一条件&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;仅通过修改放大算法，保持所有参数不变，可以得到如下所示的一系列结果。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://auold.github.io/amplification_algorithm_comparison/test1/Latent.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;test1_Latent&#34;
	
	
&gt;
&lt;strong&gt;Latent&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://auold.github.io/amplification_algorithm_comparison/test1/Latent%28antialiased%29.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;test1_Latent(antialiased)&#34;
	
	
&gt;
&lt;strong&gt;Latent(antialiased)&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://auold.github.io/amplification_algorithm_comparison/test1/Latent%28bicubic%29.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;test1_Latent(bicubic)&#34;
	
	
&gt;
&lt;strong&gt;Latent(bicubic)&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;![test1_Latent(bicubic antialias)](/amplification_algorithm_comparison/test1/Latent(bicubic antialias).png)
&lt;strong&gt;Latent(bicubic antialias)&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://auold.github.io/amplification_algorithm_comparison/test1/Latent%28nearest%29.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;test1_Latent(nearest)&#34;
	
	
&gt;
&lt;strong&gt;Latent(nearest)&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://auold.github.io/amplification_algorithm_comparison/test1/Latent%28nearest-exact%29.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;test1_Latent(nearest-exact)&#34;
	
	
&gt;
&lt;strong&gt;Latent(nearest-exact)&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://auold.github.io/amplification_algorithm_comparison/test1/None.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;test1_None&#34;
	
	
&gt;
&lt;strong&gt;无&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://auold.github.io/amplification_algorithm_comparison/test1/Lanczos.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;test1_Lanczos&#34;
	
	
&gt;
&lt;strong&gt;Lanczos&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://auold.github.io/amplification_algorithm_comparison/test1/nearest-integer.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;test1_nearest-integer&#34;
	
	
&gt;
&lt;strong&gt;最邻近(整数缩放)&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://auold.github.io/amplification_algorithm_comparison/test1/Lanczos.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;test1_Lanczos&#34;
	
	
&gt;
&lt;strong&gt;Lanczos&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://auold.github.io/amplification_algorithm_comparison/test1/swinIR_4x.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;test1_swinIR_4x&#34;
	
	
&gt;
&lt;strong&gt;SwinIR_4x&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;未来计划 controlnet之类的 高质量出图&lt;/em&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>更新时需要用到的命令</title>
        <link>https://auold.github.io/post/the_way_updating/</link>
        <pubDate>Thu, 16 Feb 2023 00:03:15 +0800</pubDate>
        
        <guid>https://auold.github.io/post/the_way_updating/</guid>
        <description>&lt;p&gt;新手上路，难免不熟练，每次更新都要去搜一搜这些命令，所以这里做一个简单的汇总，以后直接看这篇就好了。&lt;/p&gt;
&lt;p&gt;首先打开&lt;em&gt;git bash&lt;/em&gt;，跳转至&lt;em&gt;blog&lt;/em&gt;文件夹，&lt;strong&gt;注意这里是/而不是\&lt;/strong&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ cd F:/GitHub/Hugo/Sites/blog
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过 &lt;em&gt;hugo new&lt;/em&gt; 命令新建名为 &lt;em&gt;.md&lt;/em&gt; 的 &lt;em&gt;markdown&lt;/em&gt; 文件。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ hugo new post/.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打开相应文件开始劈里啪啦一顿写。&lt;/p&gt;
&lt;p&gt;写完了之后回到&lt;em&gt;git bash&lt;/em&gt;，生成静态网页，静态网页的位置在&lt;em&gt;blog\public&lt;/em&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ hugo --baseUrl=&amp;#34;https://auold.github.io/&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后进入&lt;em&gt;public&lt;/em&gt;文件夹进行推送。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ cd public
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个文件夹本身已经初始化过了，经过试验可以不需要重新&lt;em&gt;git init&lt;/em&gt;。先将所有文件添加到索引。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git add -A
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;提交代码，&amp;ldquo;&amp;ldquo;中的内容表示注释说明，必须要有，用于注释这次提交是做了什么修改。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git commit -m &amp;#34;&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将代码推送至远程仓库。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git push
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后静静地等待&lt;em&gt;github&lt;/em&gt;的&lt;em&gt;workflow&lt;/em&gt;运行起来，再把先前的&lt;em&gt;workflow&lt;/em&gt;删除就好。&lt;em&gt;（我其实并不清楚不删除会怎样，目前看起来似乎没有问题，不过总感觉删了总比不删来得清楚）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;希望能维持住更新。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>这是第一篇</title>
        <link>https://auold.github.io/post/first/</link>
        <pubDate>Tue, 14 Feb 2023 23:33:00 +0800</pubDate>
        
        <guid>https://auold.github.io/post/first/</guid>
        <description>&lt;h2 id=&#34;为什么是博客&#34;&gt;为什么是&lt;strong&gt;博客&lt;/strong&gt;？&lt;/h2&gt;
&lt;p&gt;博客虽然形式老旧且更新麻烦，但同时也带来了更高的自由度。无论是形式上还是内容上，博客都更加自由。&lt;/p&gt;
&lt;h2 id=&#34;为什么是hugogithub&#34;&gt;为什么是&lt;em&gt;Hugo&lt;/em&gt;+&lt;em&gt;Github&lt;/em&gt;？&lt;/h2&gt;
&lt;p&gt;因为&lt;em&gt;&lt;strong&gt;简单&lt;/strong&gt;&lt;/em&gt;，以目前的内容量，这个形式足够我发挥了。如果我之后真的努力更新这个站点的话，说不定会考虑再给它换个家。&lt;/p&gt;
&lt;h2 id=&#34;会写点什么&#34;&gt;会写点什么？&lt;/h2&gt;
&lt;p&gt;我主要是想&lt;strong&gt;给自己留下反刍的时间和空间&lt;/strong&gt;。目前打算什么都写，涉及技术的当然会有，但我也不想把这个地方完全变成一个技术的仓库。我发现我已经很久很久没有与自己正儿八经的聊，并且以文字为媒介把当时的所思所想记录下来了。不能说这是日记，不然就下贱了，当成听戏看小说之类的会更合适一些。&lt;/p&gt;
&lt;p&gt;缺少使用的东西总会退化，正如我的表达能力。或许现在还有救。&lt;/p&gt;
&lt;p&gt;Please. Help me.&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
